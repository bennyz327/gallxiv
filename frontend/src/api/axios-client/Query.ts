//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming
import * as Types from '../axios-client';
import { useQuery, useMutation } from '@tanstack/vue-query';
import type { UseQueryReturnType, QueryFunctionContext, UseQueryOptions, QueryClient, QueryKey, MutationKey, UseMutationOptions, UseMutationReturnType, QueryMeta, MutationMeta } from '@tanstack/vue-query';
type MaybeRef<T> = Ref<T> | T;
type NoRef<C> = C extends Ref<infer T> ? T : C;
type NoRefObject<T> = {
  [P in keyof T]: NoRef<T[P]>;
};
import { trimArrayEnd, isParameterObject, getBaseUrl, addMetaToOptions } from './helpers';
import type { Ref } from 'vue';
import * as Client from './Client'
export { Client };
import type { AxiosRequestConfig } from 'axios';

export type UserPostMutationParameters = {
  metadata?: Types.UserPostMetadataRequest | undefined ;
  images?: Types.FileParameter[] | undefined ;
}

export type GetPostQueryParameters = {
  account: MaybeRef<string> ;
  postId: MaybeRef<string> ;
}

export type GetImageQueryParameters = {
  id: MaybeRef<string> ;
}

export function userPostUrl(): string {
  let url_ = getBaseUrl() + "/api/user/post";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function userPostMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'userPost',
    ]);
}

/**
 * @param metadata (optional) 
 * @param images (optional) 
 * @return OK
 */
export function useUserPostMutation<TContext>(options?: Omit<UseMutationOptions<string, unknown, UserPostMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationReturnType<string, unknown, UserPostMutationParameters, TContext> {
  const key = userPostMutationKey();
  
  return useMutation({
    ...options,
    mutationFn: (userPostMutationParameters: UserPostMutationParameters) => Client.userPost(userPostMutationParameters.metadata as any, userPostMutationParameters.images as any),
    mutationKey: key,
  });
}
  
export function loginUrl(): string {
  let url_ = getBaseUrl() + "/api/auth/login";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function loginMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'login',
    ]);
}

/**
 * @return OK
 */
export function useLoginMutation<TContext>(options?: Omit<UseMutationOptions<void, unknown, Types.LoginRequest, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationReturnType<void, unknown, Types.LoginRequest, TContext> {
  const key = loginMutationKey();
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.LoginRequest) => Client.login(body as any),
    mutationKey: key,
  });
}
  
export function getPostUrl(account: string, postId: string): string {
  let url_ = getBaseUrl() + "/api/user/{account}/post/{postId}";
if (account === undefined || account === null)
  throw new Error("The parameter 'account' must be defined.");
url_ = url_.replace("{account}", encodeURIComponent("" + account));
if (postId === undefined || postId === null)
  throw new Error("The parameter 'postId' must be defined.");
url_ = url_.replace("{postId}", encodeURIComponent("" + postId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getPostDefaultOptions: Omit<UseQueryOptions<Types.Post, unknown, Types.Post>, 'queryKey' | 'queryFn'> = {
};
export function getGetPostDefaultOptions() {
  return getPostDefaultOptions;
};
export function setGetPostDefaultOptions(options: typeof getPostDefaultOptions) {
  getPostDefaultOptions = options;
}

export function getPostQueryKey(dto: GetPostQueryParameters): QueryKey;
export function getPostQueryKey(account: string, postId: string): QueryKey;
export function getPostQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { account, postId,  } = params[0] as GetPostQueryParameters;

    return trimArrayEnd([
        'Client',
        'getPost',
        account as any,
        postId as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'getPost',
        ...params
      ]);
  }
}
export function __getPost(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.getPost(
      context.queryKey[2] as string,       context.queryKey[3] as string,axiosConfig    );
}

export function useGetPostQuery<TSelectData = Types.Post, TError = unknown>(dto: GetPostQueryParameters, options?: Omit<UseQueryOptions<Types.Post, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryReturnType<TSelectData, TError>;
/**
 * @return OK
 */
export function useGetPostQuery<TSelectData = Types.Post, TError = unknown>(account: MaybeRef<string>, postId: MaybeRef<string>, options?: Omit<UseQueryOptions<Types.Post, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryReturnType<TSelectData, TError>;
export function useGetPostQuery<TSelectData = Types.Post, TError = unknown>(...params: any []): UseQueryReturnType<TSelectData, TError> {
  let options: UseQueryOptions<Types.Post, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let account: any = undefined;
  let postId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ account, postId,  } = params[0] as GetPostQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [account, postId, options, axiosConfig] = params;
    }
  }

  return useQuery<Types.Post, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __getPost(context, axiosConfig) : __getPost,
    queryKey: getPostQueryKey(account, postId),
    ...getPostDefaultOptions as unknown as Omit<UseQueryOptions<Types.Post, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setGetPostData(queryClient: QueryClient, updater: (data: Types.Post | undefined) => Types.Post, account: string, postId: string) {
  queryClient.setQueryData(getPostQueryKey(account, postId),
    updater
  );
}

/**
 * @return OK
 */
export function setGetPostDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.Post | undefined) => Types.Post) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function getPostsUrl(): string {
  let url_ = getBaseUrl() + "/api/posts";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getPostsDefaultOptions: Omit<UseQueryOptions<Types.Post[], unknown, Types.Post[]>, 'queryKey' | 'queryFn'> = {
};
export function getGetPostsDefaultOptions() {
  return getPostsDefaultOptions;
};
export function setGetPostsDefaultOptions(options: typeof getPostsDefaultOptions) {
  getPostsDefaultOptions = options;
}

export function getPostsQueryKey(): QueryKey;
export function getPostsQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'getPosts',
    ]);
}
export function __getPosts(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.getPosts(
axiosConfig    );
}

/**
 * @return OK
 */
export function useGetPostsQuery<TSelectData = Types.Post[], TError = unknown>(options?: Omit<UseQueryOptions<Types.Post[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryReturnType<TSelectData, TError>;
export function useGetPostsQuery<TSelectData = Types.Post[], TError = unknown>(...params: any []): UseQueryReturnType<TSelectData, TError> {
  let options: UseQueryOptions<Types.Post[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  return useQuery<Types.Post[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __getPosts(context, axiosConfig) : __getPosts,
    queryKey: getPostsQueryKey(),
    ...getPostsDefaultOptions as unknown as Omit<UseQueryOptions<Types.Post[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setGetPostsData(queryClient: QueryClient, updater: (data: Types.Post[] | undefined) => Types.Post[], ) {
  queryClient.setQueryData(getPostsQueryKey(),
    updater
  );
}

/**
 * @return OK
 */
export function setGetPostsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.Post[] | undefined) => Types.Post[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function meUrl(): string {
  let url_ = getBaseUrl() + "/api/me";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let meDefaultOptions: Omit<UseQueryOptions<Types.User, unknown, Types.User>, 'queryKey' | 'queryFn'> = {
};
export function getMeDefaultOptions() {
  return meDefaultOptions;
};
export function setMeDefaultOptions(options: typeof meDefaultOptions) {
  meDefaultOptions = options;
}

export function meQueryKey(): QueryKey;
export function meQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'me',
    ]);
}
export function __me(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.me(
axiosConfig    );
}

/**
 * @return OK
 */
export function useMeQuery<TSelectData = Types.User, TError = unknown>(options?: Omit<UseQueryOptions<Types.User, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryReturnType<TSelectData, TError>;
export function useMeQuery<TSelectData = Types.User, TError = unknown>(...params: any []): UseQueryReturnType<TSelectData, TError> {
  let options: UseQueryOptions<Types.User, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  return useQuery<Types.User, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __me(context, axiosConfig) : __me,
    queryKey: meQueryKey(),
    ...meDefaultOptions as unknown as Omit<UseQueryOptions<Types.User, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setMeData(queryClient: QueryClient, updater: (data: Types.User | undefined) => Types.User, ) {
  queryClient.setQueryData(meQueryKey(),
    updater
  );
}

/**
 * @return OK
 */
export function setMeDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.User | undefined) => Types.User) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function getImageUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/image/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getImageDefaultOptions: Omit<UseQueryOptions<Types.FileResponse, unknown, Types.FileResponse>, 'queryKey' | 'queryFn'> = {
};
export function getGetImageDefaultOptions() {
  return getImageDefaultOptions;
};
export function setGetImageDefaultOptions(options: typeof getImageDefaultOptions) {
  getImageDefaultOptions = options;
}

export function getImageQueryKey(id: string): QueryKey;
export function getImageQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as GetImageQueryParameters;

    return trimArrayEnd([
        'Client',
        'getImage',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'getImage',
        ...params
      ]);
  }
}
export function __getImage(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.getImage(
      context.queryKey[2] as string,axiosConfig    );
}

export function useGetImageQuery<TSelectData = Types.FileResponse, TError = unknown>(dto: GetImageQueryParameters, options?: Omit<UseQueryOptions<Types.FileResponse, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryReturnType<TSelectData, TError>;
/**
 * @return OK
 */
export function useGetImageQuery<TSelectData = Types.FileResponse, TError = unknown>(id: MaybeRef<string>, options?: Omit<UseQueryOptions<Types.FileResponse, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryReturnType<TSelectData, TError>;
export function useGetImageQuery<TSelectData = Types.FileResponse, TError = unknown>(...params: any []): UseQueryReturnType<TSelectData, TError> {
  let options: UseQueryOptions<Types.FileResponse, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as GetImageQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  return useQuery<Types.FileResponse, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __getImage(context, axiosConfig) : __getImage,
    queryKey: getImageQueryKey(id),
    ...getImageDefaultOptions as unknown as Omit<UseQueryOptions<Types.FileResponse, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setGetImageData(queryClient: QueryClient, updater: (data: Types.FileResponse | undefined) => Types.FileResponse, id: string) {
  queryClient.setQueryData(getImageQueryKey(id),
    updater
  );
}

/**
 * @return OK
 */
export function setGetImageDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.FileResponse | undefined) => Types.FileResponse) {
  queryClient.setQueryData(queryKey, updater);
}